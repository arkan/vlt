package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"time"
)

// bookmarksFile represents the top-level structure of .obsidian/bookmarks.json.
type bookmarksFile struct {
	Items []bookmark `json:"items"`
}

// bookmark represents a single bookmark entry. Groups contain nested items.
type bookmark struct {
	Type  string     `json:"type"`
	Ctime int64      `json:"ctime"`
	Path  string     `json:"path,omitempty"`
	Title string     `json:"title,omitempty"`
	Items []bookmark `json:"items,omitempty"`
}

// bookmarksPath returns the filesystem path to the bookmarks.json file.
func bookmarksPath(vaultDir string) string {
	return filepath.Join(vaultDir, ".obsidian", "bookmarks.json")
}

// loadBookmarks reads and parses .obsidian/bookmarks.json.
// Returns an empty bookmarksFile (no error) if the file does not exist.
func loadBookmarks(vaultDir string) (bookmarksFile, error) {
	path := bookmarksPath(vaultDir)

	data, err := os.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return bookmarksFile{Items: []bookmark{}}, nil
		}
		return bookmarksFile{}, err
	}

	var bm bookmarksFile
	if err := json.Unmarshal(data, &bm); err != nil {
		return bookmarksFile{}, fmt.Errorf("cannot parse bookmarks.json: %w", err)
	}

	if bm.Items == nil {
		bm.Items = []bookmark{}
	}
	return bm, nil
}

// saveBookmarks writes the bookmarksFile to .obsidian/bookmarks.json.
// Creates the .obsidian directory if it does not exist.
func saveBookmarks(vaultDir string, bm *bookmarksFile) error {
	obsDir := filepath.Join(vaultDir, ".obsidian")
	if err := os.MkdirAll(obsDir, 0755); err != nil {
		return fmt.Errorf("cannot create .obsidian directory: %w", err)
	}

	data, err := json.MarshalIndent(bm, "", "  ")
	if err != nil {
		return fmt.Errorf("cannot marshal bookmarks: %w", err)
	}

	return os.WriteFile(bookmarksPath(vaultDir), data, 0644)
}

// flattenBookmarks recursively collects all file-type bookmark paths,
// descending into groups.
func flattenBookmarks(items []bookmark) []string {
	var paths []string
	for _, item := range items {
		switch item.Type {
		case "file":
			paths = append(paths, item.Path)
		case "group":
			paths = append(paths, flattenBookmarks(item.Items)...)
		}
	}
	return paths
}

// containsBookmark checks whether a path is already bookmarked,
// recursing into groups.
func containsBookmark(items []bookmark, path string) bool {
	for _, item := range items {
		if item.Type == "file" && item.Path == path {
			return true
		}
		if item.Type == "group" && containsBookmark(item.Items, path) {
			return true
		}
	}
	return false
}

// addBookmark adds a file bookmark to the top-level items array.
// Returns false if the path is already bookmarked (no-op).
func addBookmark(bm *bookmarksFile, path string) bool {
	if containsBookmark(bm.Items, path) {
		return false
	}

	bm.Items = append(bm.Items, bookmark{
		Type:  "file",
		Ctime: time.Now().UnixMilli(),
		Path:  path,
	})
	return true
}

// removeBookmark removes a file bookmark matching the given path,
// searching recursively into groups. Returns false if not found.
func removeBookmark(bm *bookmarksFile, path string) bool {
	return removeFromItems(&bm.Items, path)
}

// removeFromItems removes a bookmark matching path from a slice,
// recursing into groups. Returns true if found and removed.
func removeFromItems(items *[]bookmark, path string) bool {
	for i, item := range *items {
		if item.Type == "file" && item.Path == path {
			*items = append((*items)[:i], (*items)[i+1:]...)
			return true
		}
		if item.Type == "group" {
			if removeFromItems(&(*items)[i].Items, path) {
				return true
			}
		}
	}
	return false
}

// cmdBookmarks lists all bookmarked file paths (flat, recursing into groups).
func cmdBookmarks(vaultDir string, format string) error {
	bm, err := loadBookmarks(vaultDir)
	if err != nil {
		return err
	}

	paths := flattenBookmarks(bm.Items)
	if paths == nil {
		paths = []string{}
	}

	formatList(paths, format)
	return nil
}

// cmdBookmarksAdd adds a bookmark for a note resolved by title.
func cmdBookmarksAdd(vaultDir string, params map[string]string) error {
	title := params["file"]
	if title == "" {
		return fmt.Errorf("bookmarks:add requires file=\"<title>\"")
	}

	notePath, err := resolveNote(vaultDir, title)
	if err != nil {
		return err
	}

	relPath, err := filepath.Rel(vaultDir, notePath)
	if err != nil {
		return err
	}

	bm, err := loadBookmarks(vaultDir)
	if err != nil {
		return err
	}

	if !addBookmark(&bm, relPath) {
		fmt.Printf("already bookmarked: %s\n", relPath)
		return nil
	}

	if err := saveBookmarks(vaultDir, &bm); err != nil {
		return err
	}

	fmt.Printf("bookmarked: %s\n", relPath)
	return nil
}

// cmdBookmarksRemove removes a bookmark for a note resolved by title.
func cmdBookmarksRemove(vaultDir string, params map[string]string) error {
	title := params["file"]
	if title == "" {
		return fmt.Errorf("bookmarks:remove requires file=\"<title>\"")
	}

	// Check that bookmarks.json exists (error on remove when missing)
	bmPath := bookmarksPath(vaultDir)
	if _, err := os.Stat(bmPath); os.IsNotExist(err) {
		return fmt.Errorf("no bookmarks file found in vault")
	}

	notePath, err := resolveNote(vaultDir, title)
	if err != nil {
		return err
	}

	relPath, err := filepath.Rel(vaultDir, notePath)
	if err != nil {
		return err
	}

	bm, err := loadBookmarks(vaultDir)
	if err != nil {
		return err
	}

	if !removeBookmark(&bm, relPath) {
		return fmt.Errorf("bookmark not found for %q (%s)", title, relPath)
	}

	if err := saveBookmarks(vaultDir, &bm); err != nil {
		return err
	}

	fmt.Printf("unbookmarked: %s\n", relPath)
	return nil
}
